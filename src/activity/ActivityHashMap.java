package activity;

import java.util.Iterator;
import java.util.HashMap;
import java.util.Set;
import java.util.Map;

import event.TimeStamp;

/**
 * Wrapper class for HashMap of Activities. The data structure for any
 * additional Activities that are generated by an Activity, which is
 * hashed by TimeStamp.
 * 
 * @author ewah
 */
public class ActivityHashMap {

	private HashMap<TimeStamp, PriorityActivityList> acts;
	
	public ActivityHashMap() {
		acts = new HashMap<TimeStamp, PriorityActivityList>();
	}
	
	/**
	 * Clear the HashMap structure.
	 */
	public void clear() {
		acts.clear();
	}
	
//	/**
//	 * Creates new entry hashed at the activity's TimeStamp, with a single
//	 * element ActivityList containing the given Activity. Modifies the Activity
//	 * TimeStamp to match what it is hashed at.
//	 * 
//	 * If key already exists, appends the given Activity at the end of the
//	 * ActivityList.
//	 * 
//	 * @param act
//	 * @return true if inserted correctly, false otherwise
//	 */
//	public boolean insertActivity(Activity act) {
//		return insertActivity(Consts.DEFAULT_PRIORITY, act);
//	}
	
	/**
	 * Creates new entry hashed at the activity's TimeStamp, with a single
	 * element ActivityList containing the given Activity. Modifies the Activity
	 * TimeStamp to match what it is hashed at, and sets the ActivityList to have
	 * the given priority.
	 * 
	 * If key already exists, appends the given Activity at the end of the
	 * ActivityList.
	 * 
	 * @param priority
	 * @param act
	 * @return true if inserted correctly, false otherwise
	 */
	public boolean insertActivity(int priority, Activity act) {
		if (act == null)
			return false;
		
		TimeStamp ts = act.getTime();
		if (!ts.checkActivityTimeStamp(act)) // FIXME unnecessary?
			return false;
		
		if (acts.containsKey(ts)) {
			// append Activity to ActivityList
			acts.get(ts).add(priority, act);
		} else {
			// create new key-value mapping
			ActivityList al = new ActivityList(priority, act);
			PriorityActivityList pal = new PriorityActivityList(al);
			pal.add(al);
			acts.put(ts, pal);
		}
		return true;
	}
	
	/**
	 * Creates new entry hashed at TimeStamp of activities, with an ActivityList
	 * containing the specified list of activities.
	 * 
	 * If key already exists, appends the given ActivityList at the end
	 * of the existing list.
	 * 
	 * @param al
	 * @return true if inserted correctly, false otherwise
	 */
	public boolean insertActivity(ActivityList al) {
		if (al == null) return false;
		
		TimeStamp ts = al.getTime();	
		if (acts.containsKey(ts)) {
			// append to end of the activity list with the same priority
			acts.get(ts).add(al);
		} else {
			// create new key-value mapping
			PriorityActivityList pal = new PriorityActivityList(al);
			pal.add(al);
			acts.put(ts, pal);
		}
		return true;
	}
	
	/**
	 * Creates new entry hashed at TimeStamp of activities, with an ActivityList
	 * containing the specified list of activities.
	 * 
	 * If key already exists, appends the given ActivityList at the end
	 * of the existing list.
	 * 
	 * @param ts
	 * @param pal
	 * @return true if inserted correctly, false otherwise
	 */
	public boolean insertActivity(TimeStamp ts, PriorityActivityList pal) {
		if (pal == null) return false;
		
		if (acts.containsKey(ts)) {
			// add to the priority activity list at that TimeStamp
			acts.get(ts).add(pal);
		} else {
			// create new key-value mapping
			acts.put(ts, pal);
		}
		return true;
	}
	
	/**
	 * Appends two ActivityHashMaps together. Modifies the calling Object's HashMap.
	 * 
	 * @param ahm
	 */
	public void appendActivityHashMap(ActivityHashMap ahm) {
		if (ahm != null) {
			for (Map.Entry<TimeStamp,PriorityActivityList> entry : ahm.acts.entrySet()) {
				insertActivity(entry.getKey(), entry.getValue());
			}
		}
	}
	
	/**
	 * @param ts
	 * @return
	 */
	public PriorityActivityList get(TimeStamp ts) {
		return acts.get(ts);
	}
	
	/**
	 * @param ts
	 * @return PAL associated with ts
	 */
	public PriorityActivityList remove(TimeStamp ts) {
		return acts.remove(ts);
	}
	
	/**
	 * @return true if contains no key-value pairings
	 */
	public boolean isEmpty() {
		return acts.isEmpty();
	}
	
	/**
	 * @return Set of TimeStamps (keys)
	 */
	public Set<TimeStamp> keys() {
		return acts.keySet();
	}
	
	/**
	 * @param ts
	 * @return
	 */
	public boolean containsKey(TimeStamp ts) {
		return acts.containsKey(ts);
	}
	
	/**
	 * @return Set view of mappings in this ActivityHashMap
	 */
	public Set<Map.Entry<TimeStamp,PriorityActivityList>> entrySet() {
		return acts.entrySet();
	}
	
	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		String s = "";
		for (Map.Entry<TimeStamp, PriorityActivityList> entry : acts.entrySet()) {
			s += entry.getKey().toString() + ": ";
			for (Iterator<Activity> it = entry.getValue().iterator(); it.hasNext(); ) {
				s += it.next().toString() + "...";
			}
		}
		return s;
	}

}
