package activity;

import java.util.LinkedList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.Map;

import event.TimeStamp;

/**
 * Wrapper class for HashMap of Activities. The data structure for any
 * additional Activities that are generated by an Activity, which is
 * hashed by TimeStamp.
 * 
 * @author ewah
 */
public class ActivityHashMap {

	private HashMap<TimeStamp, LinkedList<Activity>> acts;
	
	public ActivityHashMap() {
		acts = new HashMap<TimeStamp, LinkedList<Activity>>();
	}
	
	public void clear() {
		acts.clear();
	}
	
	// TODO error checking to throw an Exception when TimeStamp mismatch
	
	/**
	 * Creates new entry hashed at the activity's TimeStamp, with a single
	 * element LinkedList containing the given Activity.
	 * 
	 * If key already exists, appends the given Activity at the end of the
	 * Activity LinkedList.
	 * 
	 * @param act
	 * @return true if inserted correctly, false otherwise
	 */
	public boolean insertActivity(Activity act) {
		
		boolean ret = false;
		
		TimeStamp ts = act.getTime();
		if (!checkActivityTimeStamp(ts, act)) return false;
		
		if (acts.containsKey(ts)) {
			// append Activity to LinkedList
			ret = acts.get(ts).add(act);
		} else {
			// create new key-value mapping
			LinkedList<Activity> vec = new LinkedList<Activity>();
			ret = vec.add(act);
			acts.put(ts, vec);
		}
		
		return ret;
	}
	
	/**
	 * Creates new entry hashed at TimeStamp of activities, with a LinkedList
	 * containing the specified list of activities.
	 * 
	 * If key already exists, appends the given Activity LinkedList at the end
	 * of the existing LinkedList.
	 * 
	 * @param av
	 * @return true if inserted correctly, false otherwise
	 */
	public boolean insertMultipleActivity(LinkedList<Activity> av) {
		
		boolean ret = false;
		
		TimeStamp ts = av.get(0).getTime();
		Iterator<Activity> it = av.iterator();
		while (it.hasNext()) {
			if (!checkActivityTimeStamp(ts, it.next())) return false;
		}
		
		if (acts.containsKey(ts)) {
			// append Activity Vector to LinkedList
			ret = acts.get(ts).addAll(av);
		} else {
			// create new key-value mapping
			acts.put(ts, av);
		}
		
		return ret;
	}
	
	
	/**
	 * Appends two ActivityHashMaps together. Modifies the calling Object's HashMap.
	 * 
	 * @param ahm
	 * @return
	 */
	public boolean appendActivityHashMap(ActivityHashMap ahm) {
		
		boolean ret = true;
		
		for (Map.Entry<TimeStamp,LinkedList<Activity>> entry : ahm.acts.entrySet()) {
			ret = ret && insertMultipleActivity(entry.getValue());
		}
		
		return ret;
	}
	
	/**
	 * Verifies whether or not the Activity's TimeStamp matches the given one.
	 * 
	 * @param ts
	 * @param act
	 * @return true if matches, false otherwise.
	 */
	private boolean checkActivityTimeStamp(TimeStamp ts, Activity act) {
		
		if (act.time.equals(ts)) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * @return true if contains no key-value pairings
	 */
	public boolean isEmpty() {
		return acts.isEmpty();
	}
	
	/**
	 * @return Set of TimeStamps (keys)
	 */
	public Set<TimeStamp> keys() {
		return acts.keySet();
	}
	
	/**
	 * @return Set view of mappings in this ActivityHashMap
	 */
	public Set<Map.Entry<TimeStamp,LinkedList<Activity>>> entrySet() {
		return acts.entrySet();
	}
	
}
